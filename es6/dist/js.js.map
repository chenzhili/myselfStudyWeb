{"version":3,"sources":["../js.js"],"names":["obj1","obj2","name","age","console","log"],"mappings":";;gBA8D0B,EAACA,MAAK,KAAN,EAAYC,MAAK,IAAjB,E,EA9D1B;;;;AAKA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;AACA;;;;;;;;;;;;;;AAcA;AACA;AACA;;AAEA,kB,CAAkB;AAClB;AACI;;AACOC,I,aAALF,I;AAAeG,G,aAALF,I;;AACZG,QAAQC,GAAR,CAAYH,IAAZ;AACAE,QAAQC,GAAR,CAAYF,GAAZ","file":"js.js","sourcesContent":["/*let dir = document.querySelector(\".div\");\r\nlet btn  = document.querySelector(\"button\");\r\nconst a = 1;*/\r\n\r\n\r\n/*构造函数*/\r\n/*let f = ()=>{\r\n    console.log(1+1);\r\n};\r\nbtn.onclick =  () => {\r\n  dir.innerHTML = `<p>${a}</p>`;\r\n  carry.says(60);\r\n  guruda.call(\"sdfd\");\r\n    console.log(Boolean(d == 1));\r\n    console.log(Boolean(b == 2));\r\n    console.log(Boolean(c == 3));\r\n    console.log(obj);\r\n    fun( \"\",[true,12]);\r\n    f(0,...[1,2]);\r\n};\r\nclass Name {\r\n    constructor() {\r\n        this.name = \"tom\";\r\n    }\r\n    says(age){\r\n        console.log(`${this.name}年龄为${age}岁吗`);\r\n    }\r\n}\r\nlet carry = new Name();\r\nclass NameAo extends Name{\r\n    constructor(){\r\n      super();\r\n      this.name = \"curry\";\r\n    }\r\n    call(call){\r\n      this.says(call);\r\n    }\r\n}\r\nlet guruda = new NameAo();*/\r\n\r\n/*解构*/\r\n/*let [d,b,c]=[1,2,3];\r\nlet cat = \"tom\";\r\nlet dog = \"lili\";\r\nlet obj ={cat,dog};\r\nfunction fun (x,...y){\r\n  console.log(y.length);\r\n  console.log(y);\r\n}\r\nfunction f(x,y){\r\n  console.log(x);\r\n  console.log(y);\r\n  console.log(x+y);\r\n  console.log(String(y));\r\n}*/\r\n/*对于变量赋值时的let和const*/\r\n//1.let下的块级作用域中，不存在申明提前的说法了，并且不能进行重复申明\r\n//2.const和let相似，但是对于他只能赋值一次\r\n\r\n/*对于解构，数组解构和对象解构*///对于写法上不知道的 ([a,b]=[1,3]);  ({a,b} = {1,2})\r\n//对于解构我不知道的\r\n    //对于对象解构，可以给他换变量名 \r\n    ({obj1:name,obj2:age}={obj1:\"tom\",obj2:\"23\"})\r\n    console.log(name);\r\n    console.log(age);\r\n"]}